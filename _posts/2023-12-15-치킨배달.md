---
title: 백준15686_치킨배달(backTracking)
date: 2023-12-15 19:38:11 +09:00
categories: [알고리즘, 탐색]
tags:
  [
    백준15686,
    
    .
    .
    .
  ]
---

# <img width="20px"  src="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" class="solvedac-tier"> [치킨 배달](https://www.acmicpc.net/problem/15686) 


## 문제
<p>크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.</p>

<p>이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "<strong>치킨 거리</strong>"라는 말을 주로 사용한다. <strong>치킨 거리</strong>는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 <strong>치킨 거리</strong>를 가지고 있다. <strong>도시의 치킨 거리</strong>는 모든 집의 <strong>치킨 거리</strong>의 합이다.</p>

<p>임의의 두 칸 (r<sub>1</sub>, c<sub>1</sub>)과 (r<sub>2</sub>, c<sub>2</sub>) 사이의 거리는 |r<sub>1</sub>-r<sub>2</sub>| + |c<sub>1</sub>-c<sub>2</sub>|로 구한다.</p>

<p>예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.</p>

<pre>0 2 0 1 0
1 0 1 0 0
0 0 0 0 0
0 0 0 1 1
0 0 0 1 2
</pre>

<p>0은 빈 칸, 1은 집, 2는 치킨집이다.</p>

<p>(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.</p>

<p>(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.</p>

<p>이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.</p>

<p>도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, <strong>도시의 치킨 거리</strong>가 가장 작게 될지 구하는 프로그램을 작성하시오.</p>

## 입력
<p>첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.</p>

<p>도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.</p>

## 출력
<p>첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.</p>

## 나의코드
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {
	static ArrayList<int[]> chicken;
	static ArrayList<int[]> home;
	static int answer;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
		
		chicken = new ArrayList<>();
		home = new ArrayList<>();
		for(int i = 0 ;i < N; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			for(int j = 0 ;j < N; j++) {
				int num = Integer.parseInt(st.nextToken());
				if(num == 1) { //1 일경우 home들 list에 넣기
					home.add(new int[] {i,j});
				}
				if(num == 2) { //2 일경우 chicken집을 list에 넣기
					chicken.add(new int[] {i,j});
				}
			}
		}
		answer = Integer.MAX_VALUE;
		bfs(new int[M], 0 , 0); // 치킨집 지정 갯수만큼 int[] 설정
		System.out.println(answer);
	}
	static void bfs(int[] count, int start, int end) {
		if(count.length == end) { //치킨집 지정 갯수 와 end갯수와 같을시 
			int result = 0;
			for(int i = 0 ;i < home.size();i++) { // 집에 갯수만큼 
				int dist = Integer.MAX_VALUE;
				for(int j = 0 ;j < count.length; j++) { //지정된 치킨집 기준으로 각각 집들의 거리를 구함
					int min = Math.abs(chicken.get(count[j])[0] - home.get(i)[0]) + Math.abs(chicken.get(count[j])[1] - home.get(i)[1]);
					dist = Math.min(dist, min); // 각각 집들의 지정된 치킨집들을 구해서 가장 가까운 것으로 지정
				}
				result+=dist; // 가장 가까운 지정된 거리를 더함
			}
			answer = Math.min(answer, result); // 각각 치킨집들의 기준으로 가까운 집들을 비교하여 최소값 구함
			return;
		}
		
		for(int i = start; i<chicken.size();i++) { // 지정된 치킨집 for문
			count[end] = i; // 치킨집이(M) 이 5 면 (0,1),(2,3),(3,3) 이런식으로 담음
			bfs(count, i+1, end+1);
		}
	}
}
```

## 후기
<p>이제는 이런 알고리즘으로 풀어야겠다라고 감이 약간? 잡힌거 같지만 이제 문제의 변수들을 어떻게 설정해야할지 아직 감이 잡히지 않는다. 여기서 치킨과 집을 따로 ArrayList로 해야할지는 생각을 못했다. 계속 생각해봐야겠다.</p>