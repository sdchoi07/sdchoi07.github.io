---
title: BellMan-Ford
date: 2023-12-23 19:40:13 +09:00
categories: [알고리즘, 자료구조 이론]
tags:
  [
  BelMan-Ford,
  
  .
  .
  .
  ]
---

## 벨만포드란?
___

<div class="contents_style"><p><span>이번에 배워볼 알고리즘은 </span><b><span>벨만 포드 알고리즘(Bellman-Ford Algorithm)</span></b><span>이다. 이 알고리즘 또한 이전에 배운 다익스트라 알고리즘처럼 그래프에서 <span style="color: #000000;"><b>한 정점에서 다른 모든 정점으로 가는 최단 경로</b></span>를 구할 수 있는 알고리즘이다.</span></p>
<p><span>벨만 포드 알고리즘은 다익스트라 알고리즘보다 시간이 더 걸리지만 </span><span><span style="color: #000000;"><b>음의 간선이 존재</b></span>해도</span><span> 최단 경로를 찾을 수 있는 알고리즘이다.</span><span></span></p>
<p id="SE-d2e5881c-e3e8-4955-9c20-cc927a4c0167"><span>벨만 포드 알고리즘은 다이나믹 프로그래밍이라고 할 수 있다. 그 이유는 매번 저장해놓은 최소 비용을 이용해서 새로운 최소 비용으로 갱신하기 때문이다.</span></p>
<p id="SE-b89f9bfc-54b7-4093-acf0-99d57eb65701"><span>​</span><span>벨만 포드 알고리즘이 다익스트라 알고리즘보다 시간이 오래 걸리는 이유는 다익스트라는 최소 비용을 가지는 간선만 우선적으로 뽑으면서 경우의 수를 줄여가며 비용을 갱신하였다. 하지만 벨만 포드 알고리즘은 음의 간선 때문에 모든 경우의 수를 다 탐색하는 알고리즘이다.</span></p>
<p id="SE-0e855305-23b1-4267-ba41-0643aecaab2e"><span>​</span></p>
<p id="SE-dc1ffa26-2ae6-4d69-b454-513f4aa171f5"><span>벨만 포드 알고리즘의 동작 원리는 다음과 같다.</span><span style="letter-spacing: 0px;">​</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">

<br>

## 벨만포드 원리
___

<li id="SE-8880e3c4-1ccc-415a-9034-78a178aa25f4">시작 정점을 선택한다.</li>
<li id="SE-a83f0242-b63f-40ee-840f-a12c6034b8fb">모든 간선들을 탐색하면서, 시작 정점에서 다른 정점까지의 거리가 INF가 아니라면 거리를 갱신한다. 이 과정을 정점의 수-1번만큼 진행한다.</li>
<li id="SE-1dbe55ab-5b08-4e81-b401-c4d6071fada5">마지막으로 2번을 수행한다.</li>
</ul>
<p id="SE-a6269b64-be7f-4620-9697-e129be6df1b6">&nbsp;</p>
<p id="SE-283363b3-5d6c-4a3c-8c6c-f29ef336ac70"><span>2번 과정에서 (정점의 수-1)번 만큼 진행하는 이유는 V개의 정점과 E개의 간선이 있는 가중 그래프에서 정점 A에서 정점 B까지의 최단 거리는 최대 <span style="color: #ee2323;"><b>V-1</b></span>개의 정점을 지나기 때문이다.</span></p>
<p><span>V-1개 이상의 정점을 방문하는 것은 결국 중복 방문을 하는 것이기 때문에 최단 경로가 성립될 수 없다.</span></p>
<p><span>또한, 3번 과정에서 마지막으로 2번 과정을 한 번 더 수행하는 이유는 음의 사이클 유무를 판단하기 위해서이다. 만약 V 개의 정점을 지났는데 최단 경로가 갱신이 된다면 음의 사이클이 발생한 것이며 비용이 무한하게 갱신이 되기 때문에 최단 경로를 구할 수 없다.</span></p>
<p id="SE-d41dc64c-14c5-4c60-8930-0e118c3215c1"><span>​</span></p>

<br>

## 벨만 포드 알고리즘
___

<p></p><img src="/assets/img/favicons/bellman1.png" alt="" width="350" height="370">
<p></p>
<p>&nbsp;</p>
<p>가중치를 가지는 방향 그래프가 위 그림처럼 존재한다고 하자. 시작 정점을 1번으로 선택하고 남은 정점까지의 최단 경로를 구하는 과정을 살펴보자.</p>
<p>1번 정점에서 다른 정점으로 가는 비용은 1차원 배열로 표현한다. 초기 상태는 자신에게 가는 비용을 제외하고는 갈 수 없다는 의미로 INF로 표현한다.</p>
<p></p><img src="/assets/img/favicons/bellman2.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p>첫 번째로 모든 간선을 통해 최단 경로를 갱신한다. 2번 정점으로 가는 비용은 1-4-2로 가능 비용 6으로 갱신되고, 3번 정점으로 가는 비용은 1-4-5-3으로 가는 비용 -1로 갱신된다.</p>
<p>4번 정점으로 가는 비용은 1-4로 가는 비용 3으로 갱신되고 5번으로 가는 비용은 1-4-5로 가는 비용 -3으로 갱신된다.</p>
<p></p><img src="/assets/img/favicons/bellman3.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p>두 번째로 모든 간선을 통해 최단 경로를 갱신한다. 현재 2번으로 가는 비용 6보다 현재 3번으로 가는 비용(-1) + 4, 2번으로 가는 비용(6) = 5가 저렴하기 때문에 갱신해준다.</p>
<p>현재 3번으로 가는 비용 -1보다 현재 3번으로 가는 비용(-1) + 4, 5, 3번으로 가는 비용(-1) = -2가 저렴하기 때문에 갱신해 준다.</p>
<p>자세히 보면 3-4-5-3번 구간이 -1 값이 누적되는 음의 사이클이란 것을 확인할 수 있다. 음의 사이클로 인해 현재 3번으로 가는 비용이 -2로 갱신되면서 자연스럽게 4번과 5번으로 가는 비용이 -1만큼 갱신된다.</p>
<p></p><img src="/assets/img/favicons/bellman4.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p>세 번째로 모든 간선을 통해 최단 경로를 갱신한다. 3-4-5-3의 음의 사이클 구간 때문에 3에서 갈 수 있는 2, 3, 4, 5번 정점으로 가는 비용이 -1만큼 갱신된다.</p>
<p></p><img src="/assets/img/favicons/bellman5.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p>네 번째로 모든 간선을 통해 최단 경로를 갱신한다. 역시 마찬가지로 3-4-5-3의 음의 사이클 구간 때문에 3에서 갈 수 있는 2, 3, 4, 5번 정점으로 가는 비용이 -1만큼 갱신된다.</p>
<p></p><img src="/assets/img/favicons/bellman6.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p>우리는 직접 그려보면서 음의 사이클의 유무를 확인하였지만 컴퓨터의 입장에서는 음의 사이클의 유무를 판단할 수가 없다.</p>
<p>따라서 마지막으로 모든 간선을 통해 경로를 갱신하며 음의 사이클이 발생하는지 확인한다. 3-4-5-3으로 -1이 누적되는 음의 사이클 구간이 존재하기 때문에 2, 3, 4, 5번 정점들의 비용이 -1만큼 감소하면서 갱신이 되는 것을 확인할 수 있다.</p>
<p>즉, 음의 사이클이 존재하기 때문에 모든 정점에 대해 최단 경로를 구할 수 없다.</span></p>
<p></p><img src="/assets/img/favicons/bellman7.png" alt="" width="350" height="370"><p></p>
<p>&nbsp;</p>
<p><span>벨만 포드 알고리즘은 정점의 수만큼 모든 간선을 탐색하기 때문에</span><span><b> O(VE)</b></span><span><b>​</b></span><span>의 시간 복잡도를 가진다.</span></p>



